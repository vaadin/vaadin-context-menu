<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

  <title></title>
  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
  <script src="../../../wct-browser-legacy/browser.js"></script>
  <script type="module" src="../../../@polymer/test-fixture/test-fixture.js"></script>

  <script type="module" src="../../../@polymer/iron-test-helpers/iron-test-helpers.js"></script>
  <script type="module" src="../vaadin-context-menu.js"></script>
  <script type="module" src="./not-animated-styles.js"></script>
  <script type="module" src="../../../@polymer/polymer/lib/utils/html-tag.js"></script>
  <script src="../../../@polymer/iron-test-helpers/mock-interactions.js" type="module"></script>
  <script src="./common.js"></script>
</head>

<body>
  <test-fixture id="default">
    <template>
      <test-wrapper></test-wrapper>
    </template>
  </test-fixture>

  <script type="module">
import '@polymer/test-fixture/test-fixture.js';
import '@polymer/iron-test-helpers/iron-test-helpers.js';
import '../vaadin-context-menu.js';
import './not-animated-styles.js';
import { html } from '@polymer/polymer/lib/utils/html-tag.js';
import { PolymerElement } from '@polymer/polymer/polymer-element.js';
import { gestures } from '@polymer/polymer/lib/utils/gestures.js';
describe('mobile support', () => {
  let menu, target;
  const ios = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

  function ensureDefined(id, cb) {
    if (customElements.get(id)) {
      cb();
    } else {
      customElements.whenDefined(id).then(() => cb());
    }
  }

  ensureDefined('vaadin-context-menu', () => {
    class TestWrapper extends PolymerElement {
      static get template() {
        return html`
          <vaadin-context-menu selector="#target" id="menu">
            <div id="target">Target</div>
            <template>
              <div>Menu Content</div>
            </template>
          </vaadin-context-menu>
        `;
      }
    }
    customElements.define('test-wrapper', TestWrapper);
  });

  beforeEach(done => {
    ensureDefined('test-wrapper', () => {
      var testWrapper = fixture('default');
      menu = testWrapper.$.menu;
      target = menu.querySelector('#target');
      menu._phone = true;
      done();
    });
  });

  afterEach(() => {
    menu.close();
  });

  function makeSoloTouchEvent(type, xy, node, shiftKey = false) {
    xy = xy || middleOfNode(node);
    const touches = makeTouches([xy], node);
    const touchEventInit = {
      touches: touches,
      targetTouches: touches,
      changedTouches: touches
    };
    const event = new CustomEvent(type, {
      bubbles: true,
      cancelable: true,
      composed: true
    });

    for (const property in touchEventInit) {
      event[property] = touchEventInit[property];
    }

    event.shiftKey = shiftKey;
    node.dispatchEvent(event);
    return event;
  }

  function middleOfNode(node) {
    const bcr = node.getBoundingClientRect();
    return {
      y: bcr.top + (bcr.height / 2),
      x: bcr.left + (bcr.width / 2)
    };
  }

  function makeTouches(xyList, node) {
    let id = 0;

    return xyList.map(xy => {
      return {
        identifier: id++,
        target: node,
        clientX: xy.x,
        clientY: xy.y
      };
    });
  }

  it('should align to bottom of the viewport', done => {
    listenOnce(menu, 'opened-changed', () => {
      const styles = window.getComputedStyle(menu.$.overlay);
      expect(styles.alignItems).to.eql('stretch');
      expect(styles.justifyContent).to.eql('flex-end');
      done();
    });

    menu._setOpened(true);
  });

  it('should prevent tap', function() {
    expect(gestures.tap.info.prevent).to.be.false;
    target.dispatchEvent(new CustomEvent('contextmenu', {bubbles: true}));
    expect(gestures.tap.info.prevent).to.be.true;
  });

  if (ios) {
    it('should open on long-touch on ios', done => {
      makeSoloTouchEvent('touchstart', null, target);

      listenOnce(menu, 'opened-changed', () => {
        expect(menu.opened).to.eql(true);
        done();
      });
    });

    it('should preventDefault on touch-end after long-touch', done => {
      makeSoloTouchEvent('touchstart', null, target);

      listenOnce(menu, 'opened-changed', () => {
        const e = makeSoloTouchEvent('touchend', null, target);
        expect(e.defaultPrevented).to.be.true;
        done();
      });
    });

    it('should not open on normal tap', done => {
      makeSoloTouchEvent('touchstart', null, menu.listenOn);

      setTimeout(() => {
        makeSoloTouchEvent('tap', null, menu.listenOn);
      }, 100);

      setTimeout(() => {
        expect(menu.opened).to.eql(false);
        done();
      }, 1000);
    });

    it('should not open when `touchend` was fired too early', done => {
      const xy = middleOfNode(menu.listenOn);
      makeSoloTouchEvent('touchstart', xy, target);

      setTimeout(() => {
        makeSoloTouchEvent('touchend', null, menu.listenOn);
      }, 499);
      // Timeout for dispatching `vaadin-contextmenu` is 500

      setTimeout(() => {
        expect(menu.opened).to.eql(false);
        done();
      }, 1000);
    });

    it('should not open when `touchstart` was dispatch with `shiftKey`', done => {
      makeSoloTouchEvent('touchstart', null, target, true);

      setTimeout(() => {
        expect(menu.opened).to.eql(false);
        done();
      }, 1000);
    });

    it('should properly set `sourceEvent` on `contextmenu`', done => {
      const ev = new CustomEvent('contextmenu', {bubbles: true});
      menu.listenOn.addEventListener('vaadin-contextmenu', e => {
        expect(e.detail.sourceEvent).to.eql(ev);
        done();
      });
      target.dispatchEvent(ev);
    });

    it('should properly set `sourceEvent` on `touchstart`', done => {
      const ev = makeSoloTouchEvent('touchstart', null, target);
      menu.listenOn.addEventListener('vaadin-contextmenu', e => {
        expect(e.detail.sourceEvent).to.eql(ev);
        done();
      });
      target.dispatchEvent(ev);
    });

    it('should forward `preventDefault` to `sourceEvent`', done => {
      const ev = makeSoloTouchEvent('touchstart', null, target);
      menu.listenOn.addEventListener('vaadin-contextmenu', e => {
        e.preventDefault();
        setTimeout(() => {
          expect(ev.defaultPrevented).to.be.true;
          done();
        });
      });
      target.dispatchEvent(ev);
    });

    it('should not preventDefault on touch-end after normal tap', done => {
      makeSoloTouchEvent('touchstart', null, target);

      setTimeout(() => {
        const e = makeSoloTouchEvent('touchend', null, target);
        expect(e.defaultPrevented).to.be.false;
        done();
      }, 100);
    });

    it('should not stop `tap` bubbling in the middle of a long touch', done => {
      makeSoloTouchEvent('touchstart', null, menu.listenOn);

      setTimeout(() => {
        const evt = fire(menu, 'tap');
        expect(evt.defaultPrevented).to.eql(false);

        done();
      }, 100);
    });

    it('should not stop `tap` bubbling after a long touch', done => {
      makeSoloTouchEvent('touchstart', null, menu.listenOn);

      setTimeout(() => {
        const evt = fire(menu, 'tap');
        expect(evt.defaultPrevented).to.eql(false);

        done();
      }, 1000);
    });

    it('should stop `touchend` from creating a tap event which cancels the overlay', done => {
      const xy = middleOfNode(target);
      makeSoloTouchEvent('touchstart', xy, target);

      listenOnce(menu, 'opened-changed', () => {
        listenOnce(target, 'tap', () => {
          throw new Error('tap fired!');
        });
        setTimeout(done, 1);
        makeSoloTouchEvent('touchend', xy, target);
      });
    });

    it('should not open when touch moving', done => {
      const xy = middleOfNode(menu.listenOn);
      makeSoloTouchEvent('touchstart', xy, target);

      setTimeout(() => {
        xy.x += 16; // threshold is 15px from start
        makeSoloTouchEvent('touchmove', xy, target);
      }, 100);

      setTimeout(() => {
        expect(menu.opened).to.eql(false);
        done();
      }, 1000);
    });
  }
});
</script>

</body>

</html>
